/*
Generated by LwipMibCompiler
*/

#include "lwip/apps/snmp_opts.h"
#if LWIP_SNMP

#include <string.h>
#include "co2Sensor-mib.h"
#include "lwip/apps/snmp.h"
#include "lwip/apps/snmp_core.h"
#include "lwip/apps/snmp_scalar.h"
#include "lwip/apps/snmp_table.h"

/* --- co2SensorMIB  ----------------------------------------------------- */
static snmp_err_t c2ssensortable_get_instance(
    const u32_t* column, const u32_t* row_oid, u8_t row_oid_len,
    struct snmp_node_instance* cell_instance);
static snmp_err_t c2ssensortable_get_next_instance(
    const u32_t* column, struct snmp_obj_id* row_oid,
    struct snmp_node_instance* cell_instance);
static s16_t c2ssensortable_get_value(struct snmp_node_instance* cell_instance,
    void* value);
static const struct snmp_table_col_def c2ssensortable_columns[] = {
    { 2, SNMP_ASN1_TYPE_OCTET_STRING,
        SNMP_NODE_INSTANCE_READ_ONLY }, /* c2sSensorName */
};
static const struct snmp_table_node c2ssensortable = SNMP_TABLE_CREATE(
    1, c2ssensortable_columns, c2ssensortable_get_instance,
    c2ssensortable_get_next_instance, c2ssensortable_get_value, NULL, NULL);

static snmp_err_t c2smeasurementtable_get_instance(
    const u32_t* column, const u32_t* row_oid, u8_t row_oid_len,
    struct snmp_node_instance* cell_instance);
static snmp_err_t c2smeasurementtable_get_next_instance(
    const u32_t* column, struct snmp_obj_id* row_oid,
    struct snmp_node_instance* cell_instance);
static s16_t c2smeasurementtable_get_value(
    struct snmp_node_instance* cell_instance, void* value);
static const struct snmp_table_col_def c2smeasurementtable_columns[] = {
    { 1, SNMP_ASN1_TYPE_INTEGER,
        SNMP_NODE_INSTANCE_READ_ONLY }, /* c2sMeasurementType */
    { 2, SNMP_ASN1_TYPE_INTEGER,
        SNMP_NODE_INSTANCE_READ_ONLY }, /* c2sMeasurementValue */
};
static const struct snmp_table_node c2smeasurementtable = SNMP_TABLE_CREATE(
    2, c2smeasurementtable_columns, c2smeasurementtable_get_instance,
    c2smeasurementtable_get_next_instance, c2smeasurementtable_get_value, NULL,
    NULL);

static const struct snmp_node* const co2sensormib_subnodes[] = {
    &c2ssensortable.node.node, &c2smeasurementtable.node.node
};
static const struct snmp_tree_node co2sensormib_root = SNMP_CREATE_TREE_NODE(1, co2sensormib_subnodes);
static const u32_t co2sensormib_base_oid[] = { 1, 3, 6, 1, 4, 1, 58049, 1 };
const struct snmp_mib co2sensormib = { co2sensormib_base_oid,
    LWIP_ARRAYSIZE(co2sensormib_base_oid),
    &co2sensormib_root.node };

/*
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
LWIP MIB generator - preserved section begin
Code below is preserved on regeneration. Remove these comment lines to
regenerate code.
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
*/

#define SENSORS_MAX 10
#define SENSOR_MEASUREMENT_TYPES_MAX 10

struct sensor {
    u8_t id;
    char *name;

    u8_t *measurement_types;
    u8_t measurement_types_len;
};

static u8_t scd30_sensor_types[] = { CO2_PPM_MEASUREMENT, TEMPERATURE_MEASUREMENT, HUMIDITY_MEASUREMENT };
static u8_t battery_types[] = { BATTERY_VOLTAGE_MEASUREMENT, BATTERY_CURRENT_MEASUREMENT };

static struct sensor sensors[] = {
    { .id = 1, .name = "SCD30", .measurement_types = scd30_sensor_types, .measurement_types_len=LWIP_ARRAYSIZE(scd30_sensor_types) },
    { .id = 2, .name = "BATTERY", .measurement_types = battery_types, .measurement_types_len=LWIP_ARRAYSIZE(battery_types) }
};

static const struct snmp_oid_range sensor_table_oid_ranges[] = {
    { 1, SENSORS_MAX }
};

static const struct snmp_oid_range measurement_table_oid_ranges[] = {
    { 1, SENSORS_MAX }, { 1, SENSOR_MEASUREMENT_TYPES_MAX }
};

/* --- co2SensorMIB  ----------------------------------------------------- */
/*                  .co2SensorMib.sensorTable.sensorEntry.{column}.{measurementType}
 */
/* 1.3.6.1.4.1.58049.1.1.1.1.1 */
static snmp_err_t c2ssensortable_get_instance(
    const u32_t* column, const u32_t* row_oid, u8_t row_oid_len,
    struct snmp_node_instance* cell_instance)
{
    u8_t sensor_id;

    LWIP_UNUSED_ARG(column);

    /* check if incoming OID length and if values are in plausible range */
    if (!snmp_oid_in_range(row_oid, row_oid_len, sensor_table_oid_ranges,
            LWIP_ARRAYSIZE(sensor_table_oid_ranges))) {
        return SNMP_ERR_NOSUCHINSTANCE;
    }

    /* get netif index from incoming OID */
    sensor_id = row_oid[0];

    /* find netif with index */
    for (u8_t i = 0; i < LWIP_ARRAYSIZE(sensors); i++) {
        if (sensors[i].id == sensor_id) {
            /* store sensor index for subsequent operations (get/test/set)
          */
            cell_instance->reference.u32 = (u32_t)i;
            return SNMP_ERR_NOERROR;
        }
    }

    return SNMP_ERR_NOSUCHINSTANCE;
}

static snmp_err_t c2ssensortable_get_next_instance(const u32_t* column, struct snmp_obj_id* row_oid,
    struct snmp_node_instance* cell_instance)
{
    struct snmp_next_oid_state state;
    u32_t result_temp[LWIP_ARRAYSIZE(sensor_table_oid_ranges)];
    size_t i;

    LWIP_UNUSED_ARG(column);

    /* init struct to search next oid */
    snmp_next_oid_init(&state, row_oid->id, row_oid->len, result_temp,
        LWIP_ARRAYSIZE(sensor_table_oid_ranges));

    /* iterate over all possible OIDs to find the next one */
    for (i = 0; i < LWIP_ARRAYSIZE(sensors); i++) {
        u32_t test_oid[LWIP_ARRAYSIZE(sensor_table_oid_ranges)];

        test_oid[0] = sensors[i].id;

        /* check generated OID: is it a candidate for the next one? */
        snmp_next_oid_check(&state, test_oid,
            LWIP_ARRAYSIZE(sensor_table_oid_ranges), (void*)i);
    }

    /* did we find a next one? */
    if (state.status == SNMP_NEXT_OID_STATUS_SUCCESS) {
        snmp_oid_assign(row_oid, state.next_oid, state.next_oid_len);
        /* store sensor index for subsequent operations (get/test/set) */
        cell_instance->reference.u32 = LWIP_CONST_CAST(u32_t, state.reference);
        return SNMP_ERR_NOERROR;
    }

    /* not found */
    return SNMP_ERR_NOSUCHINSTANCE;
}

static s16_t c2ssensortable_get_value(struct snmp_node_instance* cell_instance,
    void* value)
{
    s16_t value_len;

    u32_t i = cell_instance->reference.u32;

    switch (SNMP_TABLE_GET_COLUMN_FROM_OID(cell_instance->instance_oid.id)) {
    case 2: {
        /* c2sSensorName */
        char *name = sensors[i].name;
        value_len = strlen(name);
        MEMCPY(value, name, value_len);
    } break;
    default: {
        LWIP_DEBUGF(SNMP_MIB_DEBUG, ("c2ssensortable_get_value(): unknown id: %" S32_F "\n", SNMP_TABLE_GET_COLUMN_FROM_OID(cell_instance->instance_oid.id)));
        value_len = 0;
    } break;
    }
    return value_len;
}

static snmp_err_t c2smeasurementtable_get_instance(
    const u32_t* column, const u32_t* row_oid, u8_t row_oid_len,
    struct snmp_node_instance* cell_instance)
{
    u8_t sensor_id;
    u8_t measurement_type;
    u8_t i;

    LWIP_UNUSED_ARG(column);

    /* check if incoming OID length and if values are in plausible range */
    if (!snmp_oid_in_range(row_oid, row_oid_len, measurement_table_oid_ranges,
            LWIP_ARRAYSIZE(measurement_table_oid_ranges))) {
        return SNMP_ERR_NOSUCHINSTANCE;
    }

    sensor_id = row_oid[0];
    measurement_type = row_oid[1];


    for (i = 0; i < LWIP_ARRAYSIZE(sensors); i++) {
        if (sensors[i].id == sensor_id) {
            for (u8_t j = 0; j < sensors[i].measurement_types_len; j++) {
                if (sensors[i].measurement_types[j] == measurement_type) {
                    return SNMP_ERR_NOERROR;
                }
            }
        }
    }

    return SNMP_ERR_NOSUCHINSTANCE;
}

static snmp_err_t c2smeasurementtable_get_next_instance(
    const u32_t* column, struct snmp_obj_id* row_oid,
    struct snmp_node_instance* cell_instance)
{
    struct snmp_next_oid_state state;
    u32_t result_temp[LWIP_ARRAYSIZE(measurement_table_oid_ranges)];
    u8_t i;
    u8_t j;

    LWIP_UNUSED_ARG(column);

    /* init struct to search next oid */
    snmp_next_oid_init(&state, row_oid->id, row_oid->len, result_temp,
        LWIP_ARRAYSIZE(measurement_table_oid_ranges));

    /* iterate over all possible OIDs to find the next one */

    for (i = 0; i < LWIP_ARRAYSIZE(sensors); i++) {
        for (j = 0; j < sensors[i].measurement_types_len; j++) {
            u32_t test_oid[LWIP_ARRAYSIZE(measurement_table_oid_ranges)];

            test_oid[0] = sensors[i].id;
            test_oid[1] = sensors[i].measurement_types[j];

            snmp_next_oid_check(&state, test_oid,
                LWIP_ARRAYSIZE(measurement_table_oid_ranges), NULL);
        }
    }
    /* did we find a next one? */
    if (state.status == SNMP_NEXT_OID_STATUS_SUCCESS) {
        snmp_oid_assign(row_oid, state.next_oid, state.next_oid_len);

        return SNMP_ERR_NOERROR;
    }

    /* not found */
    return SNMP_ERR_NOSUCHINSTANCE;
}

static s16_t c2smeasurementtable_get_value(
    struct snmp_node_instance* cell_instance, void* value)
{
    s16_t value_len;

    u32_t *oid = cell_instance->instance_oid.id;
    u32_t sensor_id = oid[2];
    u32_t measurement_type = oid[3];

    switch (SNMP_TABLE_GET_COLUMN_FROM_OID(cell_instance->instance_oid.id)) {
    case 1: {
        /* c2sMeasurementType */
        u8_t* v = (u8_t*)value;

        *v = measurement_type;
        value_len = sizeof(v);
    } break;
    case 2: {
        /* c2sMeasurementValue */
        int* v = (int*)value;

        *v = get_measurement(sensor_id, measurement_type);
        value_len = sizeof(v);
    } break;
    default: {
        LWIP_DEBUGF(
            SNMP_MIB_DEBUG,
            ("c2ssensortable_get_value(): unknown id: %" S32_F "\n",
                SNMP_TABLE_GET_COLUMN_FROM_OID(cell_instance->instance_oid.id)));
        value_len = 0;
    } break;
    }
    return value_len;
}

#endif /* LWIP_SNMP */
